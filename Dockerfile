# ---- Stage 1: Build Stage ----
# Use an official sbt image which includes Scala, sbt, and a compatible JDK.
# Pinning the version ensures reproducible builds.
FROM sbtscala/sbt:eclipse-temurin-17.0.8.1_1.9.7_3.3.1 as builder

# Set the working directory in the container
WORKDIR /app

# Copy project configuration and dependency files first to leverage Docker's layer cache.
# This ensures that dependencies are only re-downloaded if these files change.
COPY project/ ./project/
COPY build.sbt .

# Fetch dependencies. This layer is cached if the above files haven't changed.
RUN sbt update

# Copy the rest of the application's source code
COPY src/ ./src/

# Compile the application and create a runnable distribution using sbt-native-packager.
# The 'stage' command prepares the app in target/universal/stage.
RUN sbt stage


# ---- Stage 2: Runtime Stage ----
# Use a minimal Java Runtime Environment (JRE) base image for a smaller final image.
# Ensure the JRE version matches the JDK from the build stage.
FROM eclipse-temurin:17-jre-focal

# Create a dedicated non-root user and group for security.
RUN groupadd -r appgroup && useradd --no-log-init -r -g appgroup appuser

# Set the working directory for the runtime stage.
WORKDIR /app

# Copy the packaged application from the builder stage.
# Use --chown to set the correct permissions for the non-root user.
COPY --from=builder --chown=appuser:appgroup /app/target/universal/stage/ .

# Switch to the non-root user to run the application.
USER appuser

# Expose the port your application listens on (e.g., for a web server).
# Replace 9000 with your application's port.
EXPOSE 9000

# Define the command to run the application.
# The script is generated by sbt-native-packager.
# IMPORTANT: Replace 'your-app-name' with the 'name' defined in your build.sbt file.
ENTRYPOINT ["./bin/your-app-name"]
